# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QueryToolDialog
                                 A QGIS plugin
 The plugin is use to make query on shapefile
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-08-16
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Previan 
        email                : jjtakodjou@pavemetrics.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

import self as self
from qgis.core import *
from processing.core.Processing import Processing

Processing.initialize()
from processing.tools import *

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import *
from qgis.PyQt.QtCore import QVariant

from qgis.utils import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Query_Tool_dialog_base.ui'))


class QueryToolDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None, iface=None):
        """Constructor."""
        super(QueryToolDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # From Tie --> Open Shapefile From Qgis
        # This filter the mMapLayerComboBox_layer_analyse to display only vector layer
        self.mMapLayerComboBox_layer_analyse.setFilters(QgsMapLayerProxyModel.VectorLayer)
        # Add field fid when the layer change
        # self.mMapLayerComboBox_layer_analyse.layerChanged.connect(self.addFieldToLayer) #test
        self.mMapLayerComboBox_layer_analyse.layerChanged.connect(self.addFields) # bon
        # Check if checkBox_concrete2 is checked and connect selectConcrete2 function
        self.checkBox_concrete2.clicked.connect(self.selectConcrete2)
        # Connect checkBox_and to andIsChecked function
        self.checkBox_or.clicked.connect(self.orIsChecked)
        # 
        self.checkBox_orW.clicked.connect(self.orIsCheckedW)
        # Check if checkBox_wood3 is checked and connect selectWood3 function
        self.checkBox_wood3.clicked.connect(self.selectWood3)
        # Open save file dialog
        self.toolButton_saveQ.clicked.connect(self.getSaveFileName)
        
        self.iface = iface
        self.toolButtonW.clicked.connect(self.getOpenFilename)
        self.toolButton_saveW.clicked.connect(self.getSaveFileNameW)
        #self.layer = None
    
    # Function from Tie --> Open Shapefile From Qgis
    # Create FID field that identify all the feature (unique)
    # This function extract the name of field in a layer and create a list
    def getFieldsNameList(self):
        self.layer = self.mMapLayerComboBox_layer_analyse.currentLayer()
        liste = []
        for field in self.layer.fields():
            liste.append(field.name())
        #print(liste)
        return liste
        # if (self.tabWidget.currentIndex() == 0):
        #     self.layer = self.mMapLayerComboBox_layer_analyse.currentLayer()
        # else:
        #     #self.layer = self.iface.vectorLayer(self.fnO, '', 'ogr')
        #     self.layer = self.iface.activeLayer()
    
    # This fonction check if the layer dosn't have a field (the len of the layer without field is 9) if not add this field.
    def addFields(self):
        if len(self.getFieldsNameList()) >= 9:
            caps = self.layer.dataProvider().capabilities()
            if caps & QgsVectorDataProvider.DeleteFeatures:
                res = self.layer.dataProvider().deleteFeatures([9, len(self.getFieldsNameList())])
                self.layer.updateFields()
        else:
            caps = self.layer.dataProvider().capabilities()
            if caps & QgsVectorDataProvider.AddAttributes:
                res = self.layer.dataProvider().addAttributes([QgsField("fid", QVariant.Int)])
            self.layer.updateFields()
        
    def addFeatureFidField(self):
        self.layer.startEditing()
        for feat in self.layer.getFeatures():
            feat["fid"] = feat.id()
            self.layer.updateFeature(feat)

        self.layer.commitChanges()
        
 
    # def processOkClicked(self):
    #     self.fn = self.lineEdit_saveQ.text()
    #     self.fnO = self.lineEdit_analyseW.text()  # fn : Open shapefile
    #     activeTab = self.tabWidget.currentIndex()
        
    #     if (activeTab == 0):
    #         print("0")
    #         self.layer = self.mMapLayerComboBox_layer_analyse.currentLayer()
            
    #     else:
    #         print("1")
    #         self.fn = self.lineEdit_saveW.text() # fn : Save shapefile
            
    #         if os.path.exists(self.fnO):
    #             self.layer = self.iface.addVectorLayer(self.fnO, '', 'ogr')
    #         else:
    #             self.iface.messageBar().pushMessage("File does not exist", self.fnO, level=0)
        
    #     self.getFieldsNameList()
    #     self.addFields()
    #     self.addFeatureFidField()
    
    #     if self.checkBox_concrete2.isChecked():
    #         self.selectConcrete2()
        
    #     if self.checkBox_concrete2.isChecked() == False:
    #         self.layer.removeSelection()
        
    #     if self.checkBox_or.isChecked():
    #         self.selectWood3()
    #     self.extractListValueFromFID()
    #     self.find_clusters_v2()
        
    #     if self.spinBox_NumberOfTies.value() <= max(self.find_clusters_v2()):
    #         self.iface.messageBar().pushMessage("Le nombre maximun consecutifs de clusters est de : " + str(max(self.find_clusters_v2())), level=0, duration = 5)
    #         self.sectionsFromClusters()
    #         self.selectConsecutiveValue()
    #         self.writeShapefile()
    #         self.loadLayers()
    #     else:
    #         self.iface.messageBar().pushMessage("Il y'a pas " + str(self.spinBox_NumberOfTies.value()) + \
    #             " clusters dans ce shapefile. Veuillez entrer un nombre inferieur ou egale a " + str(max(self.find_clusters_v2())), level=2, duration = 10)
        
    #     self.layer.removeSelection()


    # def loadLayers(self):
    #     if os.path.exists(self.fn):
    #         self.iface.addVectorLayer(self.fn, '', 'ogr')
    #     else:
    #         self.iface.messageBar().pushMessage("File does not exist", self.fn, level=0)
            
            
    #fn = self.dlg.lineEdit_saveQ.text()
    #if os.path.exists(fn):
        #self.iface.addVectorLayer(fn, '', 'ogr')
    #else:
        #self.iface.messageBar().pushMessage("File does not exist", fn, level=0)
        
    
    
    
    #AddFieldToLayer-------------------

    # def addFieldToLayer(self):
    #     self.layer = self.mMapLayerComboBox_layer_analyse.currentLayer()
    #     self.caps = self.layer.dataProvider().capabilities()
    #     if self.caps & QgsVectorDataProvider.AddAttributes:
    #             res = self.layer.dataProvider().addAttributes([QgsField("fid", QVariant.Int)])
    #             self.layer.updateFields()
           
    # def deleteFieldToLayer(self):     
    #     print(len(self.getFieldsNameList()))
    #     self.layer = self.mMapLayerComboBox_layer_analyse.currentLayer()
    #     if len(self.getFieldsNameList()) > 9:
    #         self.caps = self.layer.dataProvider().capabilities()
    #         if self.caps & QgsVectorDataProvider.DeleteFeatures:
    #             res = self.layer.dataProvider().deleteFeatures([9, len(self.getFieldsNameList())])
    #             self.layer.updateFields()
    #             print(len(self.getFieldsNameList()))
    
    
        # else:
        #     caps = self.layer.dataProvider().capabilities()
        #     if caps & QgsVectorDataProvider.AddAttributes:
        #         res = self.layer.dataProvider().addAttributes([QgsField("fid", QVariant.Int)])
        #         self.layer.updateFields()

        # self.layer = self.mMapLayerComboBox_layer_analyse.currentLayer()
        # self.caps = self.layer.dataProvider().capabilities()
        # if self.caps & QgsVectorDataProvider.AddAttributes:
        #     res = self.layer.dataProvider().addAttributes([QgsField("fid", QVariant.Int)])
        # self.layer.updateFields()
        # pv = self.layer.dataProvider()
        # pv.addAttributes([QgsField('fid', QVariant.Int)])
        # self.layer.updateFields()

    

    # This function select the feature that TieMateria = concrete and Rating = 2
    def selectConcrete2(self):
        self.selection = self.layer.selectByExpression('"TieMateria"=\'concrete\' and "Rating"=2')
        
   

    # If or is  checked automatically checkBox_wood3 is checked
    """def orIsChecked(self, checkboxOr, checkboxWood):
        if self.checkboxOr.isChecked():
            # self.checkBox_and.setChecked(True)
            self.checkboxWood.setChecked(True)
        else:
            self.checkboxWood.setChecked(False)"""
        
    def orIsChecked(self):
        if self.checkBox_or.isChecked():
            # self.checkBox_and.setChecked(True)
            self.checkBox_wood3.setChecked(True)
        else:
            self.checkBox_wood3.setChecked(False)
            
    def orIsCheckedW(self):
        if self.checkBox_orW.isChecked():
            # self.checkBox_and.setChecked(True)
            self.checkBox_wood3W.setChecked(True)
        else:
            self.checkBox_wood3W.setChecked(False)

    # This function select the feature that TieMateria = wood and Rating = 3 and add to the previous selection (selectConcrete2)
    def selectWood3(self):
        self.selection = self.layer.selectByExpression('"TieMateria"=\'wood\' and "Rating"=3',
                                                       QgsVectorLayer.SelectBehavior.AddToSelection)

    # Extract value from the fid field and sort and return a list
    def extractListValueFromFID(self):
        layer_selection = self.layer.selectedFeatures()
        liste = []
        for feat in layer_selection:
            liste.append(feat['fid'])
        liste.sort()
        print("Taille de la liste des elements selectionnees : " +  str(len(liste)))
        return liste

    # Extract Consecutives values fonctions :

    def find_clusters_v2(self):
        arr = self.extractListValueFromFID()
        clusters = {}
        ibeg = 0  # beginning of current checked range
        iend = 0  # end of current checked range
        inext = 1  # next item to check
        while iend < len(arr):
            if inext == len(arr) or arr[inext] - arr[iend] != 1:
                # Distance between values is too large or we reached the end,
                # add cluster if larger than 1 (we need 2 to have a cluster)
                dst = iend - ibeg + 1
                if dst > 1:
                    if not dst in clusters:
                        clusters[dst] = []

                    clusters[dst].append(arr[ibeg])

                ibeg = inext
                iend = ibeg

            iend = inext
            inext = iend + 1
        # print(dict(sorted(clusters.items())))
        return dict(sorted(clusters.items()))

    # Extract consecutives values from clusters that keys is upper or equal than count
    def sectionsFromClusters(self):
        clusters = self.find_clusters_v2()
        count = self.spinBox_NumberOfTies.value()
        vec = []
        for key, value in clusters.items():
            if key < count:
                pass
            else:
                for element in value:
                    i = 0
                    while i < key:
                        vec.append(element + i)
                        i += 1
        # print(len(vec))
        return vec

    # This return the max number of consecutives clusters
    # def maxKeyClusters(self):
    #     clusters = self.find_clusters_v2()
    #     vecKey = []
    #     [vecKey.append(key) for key in clusters.keys()]
    #     for element in vecKey:
    #         maxe = element
    #         if element > maxe:
    #             maxe = element
    #     #return max(clusters.keys())
    #     return maxe

    # def consecutiveValueListExtracted(self):
    #     Results = []
    #     ClientSize = self.spinBox_NumberOfTies.value()
    #     liste = self.extractListValueFromFID()
    #     SizeListClient = len(liste) - ClientSize
    #     test2 = []
    #     for i in range(0, SizeListClient):
    #         Results.clear()
    #         # print(liste[i])
    #         IsSerie = 1;
    #         for t in range(0, ClientSize):
    #             Results.append(liste[i + t])
    #         for t in range(0, ClientSize - 1):
    #             if (Results[t + 1] - Results[t] != 1):
    #                 IsSerie = 0
    #                 break
    #         if (IsSerie == 1):
    #             for element in Results:
    #                 if element not in test2:
    #                     test2.append(element)
    #     """if len(test2) <= ClientSize:
    #         iface.messageBar().pushMessage("il y'a pas {} Ties consecutives".format(ClientSize),  level=0)
    #         return []
    #     else:"""
    #     return test2

    # Select from the list and add to the previous selection (selectWood3) : This function select consecutives tie

    def selectConsecutiveValue(self):
        liste = self.sectionsFromClusters()
        for i in range(0, len(liste)):
            if i == 0:
                self.selection = self.layer.selectByExpression('"fid" = {}'.format(liste[i]))
            else:
                self.selection = self.layer.selectByExpression('"fid" = {}'.format(liste[i]),
                                                               QgsVectorLayer.SelectBehavior.AddToSelection)

        """for i in range(0, len(liste)):
            if i == 0:
                selection = lyr.selectByExpression('"fid" = {}'.format(liste[i]))
            else:
                selection = lyr.selectByExpression('"fid" = {}'.format(liste[i]),
                                                   QgsVectorLayer.SelectBehavior.AddToSelection)"""
    def getCurrentIndex(self):
        # Tab1
        if self.tabWidget.currentIndex() == 0:
            return True;
        # Tab2
        else:
            return False;
    # Tab widget 2 (windows)

    def getOpenFilename(self):
        fnw = QtWidgets.QFileDialog.getOpenFileName(self, 'Open file')[0]
        self.lineEdit_analyseW.setText(fnw)

    def getSaveFileNameW(self):
        self.fnw = QtWidgets.QFileDialog.getSaveFileName(self, 'Save file')[0]
        self.lineEdit_saveW.setText(self.fnw)

    def writeShapefilew(self):
        writer = QgsVectorFileWriter.writeAsVectorFormat(self.layer, self.fnw, 'utf-8', driverName='ESRI Shapefile',
                                                         onlySelected=True)

    def getSaveFileName(self):
        self.fn = QtWidgets.QFileDialog.getSaveFileName(self, 'Save file')[0]
        self.lineEdit_saveQ.setText(self.fn)

    def writeShapefile(self):
        writer = QgsVectorFileWriter.writeAsVectorFormat(self.layer, self.fn, 'utf-8', driverName='ESRI Shapefile',
                                                         onlySelected=True)

    def selectRadioButtonShapefile(self):
        if self.radioButton_Qgis.isChecked():
            self.label_2.setVisible(False)

            self.lineEdit_analysis.setText('Open Shapefile from Qgis')
        if self.radioButton_Window.isChecked():
            self.lineEdit_analysis.setText('Open Shapefile from Window')
