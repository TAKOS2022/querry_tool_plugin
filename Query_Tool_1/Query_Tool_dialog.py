# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QueryToolDialog
                                 A QGIS plugin
 The plugin is use to make query on shapefile
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-08-16
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Previan 
        email                : jjtakodjou@pavemetrics.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

import self as self
from qgis.core import *
from processing.core.Processing import Processing

Processing.initialize()
from processing.tools import *

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import *
from qgis.PyQt.QtCore import QVariant

from qgis.utils import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Query_Tool_dialog_base.ui'))


class QueryToolDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(QueryToolDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # From Tie --> Open Shapefile From Qgis
        # This filter the mMapLayerComboBox_layer_analyse to display only vector layer
        self.mMapLayerComboBox_layer_analyse.setFilters(QgsMapLayerProxyModel.VectorLayer)
        # Add field fid when the layer change
        # self.mMapLayerComboBox_layer_analyse.layerChanged.connect(self.addFieldToLayer) #test
        
        self.mMapLayerComboBox_layer_analyse.layerChanged.connect(self.addFields) # bon
        # Check if checkBox_concrete2 is checked and connect selectConcrete2 function
        self.checkBox_concrete2.clicked.connect(self.selectConcrete2)
        # Connect checkBox_and to andIsChecked function
        self.checkBox_or.clicked.connect(self.orIsChecked)
        # 
        self.checkBox_orW.clicked.connect(self.orIsCheckedW)
        # Check if checkBox_wood3 is checked and connect selectWood3 function
        self.checkBox_wood3.clicked.connect(self.selectWood3)
        # Open save file dialog
        self.toolButton_saveQ.clicked.connect(self.getSaveFileName)
        
        self.toolButtonW.clicked.connect(self.getOpenFilename)
        self.toolButton_saveW.clicked.connect(self.getSaveFileNameW)

       
    # Function from Tie --> Open Shapefile From Qgis
    # Create FID field that identify all the feature (unique)
    # This function extract the name of field in a layer and create a list
    
    def getFieldsNameList(self):
        liste = []
        self.layer = self.mMapLayerComboBox_layer_analyse.currentLayer()
        # print(self.layer.name())
        for field in self.layer.fields():
            liste.append(field.name())
        #print(liste)
        return liste
       
    # This fonction check if the layer dosn't have a field (the len of the layer without field is 9) if not add this field.
    def addFields(self):
        if len(self.getFieldsNameList()) >= 9:
            caps = self.layer.dataProvider().capabilities()
            if caps & QgsVectorDataProvider.DeleteFeatures:
                res = self.layer.dataProvider().deleteFeatures([9, len(self.getFieldsNameList())])
                self.layer.updateFields()
        else:
            caps = self.layer.dataProvider().capabilities()
            if caps & QgsVectorDataProvider.AddAttributes:
                res = self.layer.dataProvider().addAttributes([QgsField("fid", QVariant.Int)])
            self.layer.updateFields()
        
    def addFeatureFidField(self):
        self.layer.startEditing()
        for feat in self.layer.getFeatures():
            feat["fid"] = feat.id()
            self.layer.updateFeature(feat)

        self.layer.commitChanges()
        
 
    # This function select the feature that TieMateria = concrete and Rating = 2
    def selectConcrete2(self):
        self.selection = self.layer.selectByExpression('"TieMateria"=\'concrete\' and "Rating"=2')
        
   

    # If or is  checked automatically checkBox_wood3 is checked
    """def orIsChecked(self, checkboxOr, checkboxWood):
        if self.checkboxOr.isChecked():
            # self.checkBox_and.setChecked(True)
            self.checkboxWood.setChecked(True)
        else:
            self.checkboxWood.setChecked(False)"""
        
    def orIsChecked(self):
        if self.checkBox_or.isChecked():
            # self.checkBox_and.setChecked(True)
            self.checkBox_wood3.setChecked(True)
        else:
            self.checkBox_wood3.setChecked(False)
            
    def orIsCheckedW(self):
        if self.checkBox_orW.isChecked():
            # self.checkBox_and.setChecked(True)
            self.checkBox_wood3W.setChecked(True)
        else:
            self.checkBox_wood3W.setChecked(False)

    # This function select the feature that TieMateria = wood and Rating = 3 and add to the previous selection (selectConcrete2)
    def selectWood3(self):
        self.selection = self.layer.selectByExpression('"TieMateria"=\'wood\' and "Rating"=3',
                                                       QgsVectorLayer.SelectBehavior.AddToSelection)

    # Extract value from the fid field and sort and return a list
    def extractListValueFromFID(self):
        layer_selection = self.layer.selectedFeatures()
        liste = []
        for feat in layer_selection:
            liste.append(feat['fid'])
        liste.sort()
        # print("Taille de la liste des elements selectionnees : " +  str(len(liste)))
        return liste

    # Extract Consecutives values fonctions :

    def find_clusters_v2(self):
        arr = self.extractListValueFromFID()
        clusters = {}
        ibeg = 0  # beginning of current checked range
        iend = 0  # end of current checked range
        inext = 1  # next item to check
        while iend < len(arr):
            if inext == len(arr) or arr[inext] - arr[iend] != 1:
                # Distance between values is too large or we reached the end,
                # add cluster if larger than 1 (we need 2 to have a cluster)
                dst = iend - ibeg + 1
                if dst > 1:
                    if not dst in clusters:
                        clusters[dst] = []

                    clusters[dst].append(arr[ibeg])

                ibeg = inext
                iend = ibeg

            iend = inext
            inext = iend + 1
        # print(dict(sorted(clusters.items())))
        return dict(sorted(clusters.items()))

    # Extract consecutives values from clusters that keys is upper or equal than count
    def sectionsFromClusters(self):
        clusters = self.find_clusters_v2()
        count = self.spinBox_NumberOfTies.value()
        vec = []
        for key, value in clusters.items():
            if key < count:
                pass
            else:
                for element in value:
                    i = 0
                    while i < key:
                        vec.append(element + i)
                        i += 1
        # print(len(vec))
        return vec

    
    # Select from the list and add to the previous selection (selectWood3) : This function select consecutives tie

    def selectConsecutiveValue(self):
        liste = self.sectionsFromClusters()
        for i in range(0, len(liste)):
            if i == 0:
                self.selection = self.layer.selectByExpression('"fid" = {}'.format(liste[i]))
            else:
                self.selection = self.layer.selectByExpression('"fid" = {}'.format(liste[i]),
                                                               QgsVectorLayer.SelectBehavior.AddToSelection)
   

    def getOpenFilename(self):
        fnw = QtWidgets.QFileDialog.getOpenFileName(self, 'Open file')[0]
        self.lineEdit_analyseW.setText(fnw)

    def getSaveFileNameW(self):
        self.fnw = QtWidgets.QFileDialog.getSaveFileName(self, 'Save file')[0]
        self.lineEdit_saveW.setText(self.fnw)

    def writeShapefilew(self):
        writer = QgsVectorFileWriter.writeAsVectorFormat(self.layer, self.fnw, 'utf-8', driverName='ESRI Shapefile',
                                                         onlySelected=True)

    # Save shapefile and set the path to the lineEdit
    def getSaveFileName(self):
        self.fnS = QtWidgets.QFileDialog.getSaveFileName(self, 'Save file')[0]
        self.lineEdit_saveQ.setText(self.fnS)

    def writeShapefile(self):
        self.fn = self.lineEdit_saveQ.text()
        writer = QgsVectorFileWriter.writeAsVectorFormat(self.layer, self.fn, 'utf-8', driverName='ESRI Shapefile',
                                                         onlySelected=True)

    def selectRadioButtonShapefile(self):
        if self.radioButton_Qgis.isChecked():
            self.label_2.setVisible(False)

            self.lineEdit_analysis.setText('Open Shapefile from Qgis')
        if self.radioButton_Window.isChecked():
            self.lineEdit_analysis.setText('Open Shapefile from Window')
